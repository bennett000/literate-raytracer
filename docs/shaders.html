<!DOCTYPE html>

<html>
<head>
  <title>shaders.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="custom.css" />
  <link rel="shortcut icon" href="https://literate-raytracer.michaeljbennett.info/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="https://literate-raytracer.michaeljbennett.info/favicon-16x16.png">
  <link rel="icon" type="image/png" sizes="32x32" href="https://literate-raytracer.michaeljbennett.info/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="48x48" href="https://literate-raytracer.michaeljbennett.info/favicon-48x48.png">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="theme-color" content="#fff">
  <meta name="application-name" content="literate-raytracer">
  <link rel="apple-touch-icon" sizes="57x57" href="https://literate-raytracer.michaeljbennett.info/apple-touch-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="https://literate-raytracer.michaeljbennett.info/apple-touch-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="https://literate-raytracer.michaeljbennett.info/apple-touch-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="https://literate-raytracer.michaeljbennett.info/apple-touch-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="https://literate-raytracer.michaeljbennett.info/apple-touch-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="https://literate-raytracer.michaeljbennett.info/apple-touch-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="https://literate-raytracer.michaeljbennett.info/apple-touch-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="https://literate-raytracer.michaeljbennett.info/apple-touch-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="167x167" href="https://literate-raytracer.michaeljbennett.info/apple-touch-icon-167x167.png">
  <link rel="apple-touch-icon" sizes="180x180" href="https://literate-raytracer.michaeljbennett.info/apple-touch-icon-180x180.png">
  <link rel="apple-touch-icon" sizes="1024x1024" href="https://literate-raytracer.michaeljbennett.info/apple-touch-icon-1024x1024.png">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="literate-raytracer">
  <link rel="apple-touch-startup-image" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"    href="https://literate-raytracer.michaeljbennett.info/apple-touch-startup-image-640x1136.png">
  <link rel="apple-touch-startup-image" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"    href="https://literate-raytracer.michaeljbennett.info/apple-touch-startup-image-750x1334.png">
  <link rel="apple-touch-startup-image" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"    href="https://literate-raytracer.michaeljbennett.info/apple-touch-startup-image-828x1792.png">
  <link rel="apple-touch-startup-image" media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"    href="https://literate-raytracer.michaeljbennett.info/apple-touch-startup-image-1125x2436.png">
  <link rel="apple-touch-startup-image" media="(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"    href="https://literate-raytracer.michaeljbennett.info/apple-touch-startup-image-1242x2208.png">
  <link rel="apple-touch-startup-image" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"    href="https://literate-raytracer.michaeljbennett.info/apple-touch-startup-image-1242x2688.png">
  <link rel="apple-touch-startup-image" media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"   href="https://literate-raytracer.michaeljbennett.info/apple-touch-startup-image-1536x2048.png">
  <link rel="apple-touch-startup-image" media="(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"   href="https://literate-raytracer.michaeljbennett.info/apple-touch-startup-image-1668x2224.png">
  <link rel="apple-touch-startup-image" media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"   href="https://literate-raytracer.michaeljbennett.info/apple-touch-startup-image-1668x2388.png">
  <link rel="apple-touch-startup-image" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"  href="https://literate-raytracer.michaeljbennett.info/apple-touch-startup-image-2048x2732.png">
  <link rel="apple-touch-startup-image" media="(device-width: 810px) and (device-height: 1080px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"  href="https://literate-raytracer.michaeljbennett.info/apple-touch-startup-image-1620x2160.png">
  <link rel="apple-touch-startup-image" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"   href="https://literate-raytracer.michaeljbennett.info/apple-touch-startup-image-1136x640.png">
  <link rel="apple-touch-startup-image" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"   href="https://literate-raytracer.michaeljbennett.info/apple-touch-startup-image-1334x750.png">
  <link rel="apple-touch-startup-image" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"   href="https://literate-raytracer.michaeljbennett.info/apple-touch-startup-image-1792x828.png">
  <link rel="apple-touch-startup-image" media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"   href="https://literate-raytracer.michaeljbennett.info/apple-touch-startup-image-2436x1125.png">
  <link rel="apple-touch-startup-image" media="(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"   href="https://literate-raytracer.michaeljbennett.info/apple-touch-startup-image-2208x1242.png">
  <link rel="apple-touch-startup-image" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"   href="https://literate-raytracer.michaeljbennett.info/apple-touch-startup-image-2688x1242.png">
  <link rel="apple-touch-startup-image" media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"  href="https://literate-raytracer.michaeljbennett.info/apple-touch-startup-image-2048x1536.png">
  <link rel="apple-touch-startup-image" media="(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"  href="https://literate-raytracer.michaeljbennett.info/apple-touch-startup-image-2224x1668.png">
  <link rel="apple-touch-startup-image" media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"  href="https://literate-raytracer.michaeljbennett.info/apple-touch-startup-image-2388x1668.png">
  <link rel="apple-touch-startup-image" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)" href="https://literate-raytracer.michaeljbennett.info/apple-touch-startup-image-2732x2048.png">
  <link rel="apple-touch-startup-image" media="(device-width: 810px) and (device-height: 1080px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"  href="https://literate-raytracer.michaeljbennett.info/apple-touch-startup-image-2160x1620.png">
  <link rel="icon" type="image/png" sizes="228x228" href="https://literate-raytracer.michaeljbennett.info/coast-228x228.png">
  <meta name="msapplication-TileColor" content="#fff">
  <meta name="msapplication-TileImage" content="https://literate-raytracer.michaeljbennett.info/mstile-144x144.png">
  <meta name="msapplication-config" content="https://literate-raytracer.michaeljbennett.info/browserconfig.xml">
</head>
<body>
  <div id="container">
    <div class="cred">
        <a href="https://github.com/tmcw/literate-raytracer">based on an open source project by tom macwright</a>,
        <a href="https://github.com/bennett000/literate-raytracer">extended by michael bennett</a>
    </div>
    <center><canvas id="c"></canvas></center>
    <center id="l"></center>
    <center id="i"></center>
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="accelerators.html">
                accelerators.js
              </a>
            
              
              <a class="source" href="cube.html">
                cube.js
              </a>
            
              
              <a class="source" href="gl.html">
                gl.js
              </a>
            
              
              <a class="source" href="html.html">
                html.js
              </a>
            
              
              <a class="source" href="index.html">
                index.js
              </a>
            
              
              <a class="source" href="log.html">
                log.js
              </a>
            
              
              <a class="source" href="matrix.html">
                matrix.js
              </a>
            
              
              <a class="source" href="scene.html">
                scene.js
              </a>
            
              
              <a class="source" href="shader-configuration.html">
                shader-configuration.js
              </a>
            
              
              <a class="source" href="shaders.html">
                shaders.js
              </a>
            
              
              <a class="source" href="utility.html">
                utility.js
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>shaders.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <h2 id="shader">Shader</h2>
<p>Shaders are programs that run on the GPU.  In OpenGL and specifically WebGL
there are two different programs that work together.  There’s a vertex shader
and there’s a fragment shader.  They’re both part of a <em>rasterization</em> pipeline</p>
<p>we’re not rasterizing (much).</p>
<p>Instead of rasterizing 3D objects as OpenGL intended, we’ll be rasterizing a
rectangle the size of our view 😂</p>
<p>Normally in OpenGL we’d run a <em>vertex</em> shader on each point in a triangle, and for each
<em>fragment</em> (pixel) in the triangle, we’d run a <em>fragment</em> shader to compute the colour.</p>
<ul>
<li>Our vertex shader will essentially do “nothing”, and we can not think about it too much</li>
<li>Our fragment shader will run on each pixel and is essentially the “body” of this application</li>
</ul>
<p>For more information on <a href="https://webglfundamentals.org/" title="Deeply learn about shaders">shaders checkout WebGL Fundamentals</a></p>
<p><a name="vertexShader"></a></p>
<h3 id="vertex-shader">Vertex Shader</h3>
<p>Our vertex shader code is a simple string</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getVertexSource</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">``</span> +</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>Vertex shaders can take two types of input</p>
<ul>
<li><code>attribute</code>s</li>
<li>uniforms`</li>
</ul>
<p>In this app we can effectively ignore the vertex shader and we won’t be binding
and uniforms to it</p>
<p>The only attributes we’ll use are the 3 points of each of the 2 triangles
that make up our rectangle</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-string">`
    attribute vec4 a_position; `</span> +</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>our main function in this version of GLSL has one obligation and that is to set
<code>gl_Position</code> to some value.  <code>gl_Position</code> is a <code>vec4</code> x/y/z/w</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-string">`    void main() {
       gl_Position = a_position;
    }
`</span>;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p><a name="fragmentShader"></a></p>
<h3 id="fragment-shader">Fragment Shader</h3>
<p>The fragment shader is the body of our application it figures out what colour to make
each pixel</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFragmentSource</span>(<span class="hljs-params">config</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>for brevity’s sake break out the config values</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">const</span> { bg, defaultF0, epsilon, lightCount, materialCount, phongSpecularExp, sphereCount, triangleCount, } = config;</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>Then we’ll get into the source
we start by telling WebGL what level of precision we require with floats
we could probably get away with highp but mediump is more universally supported</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">return</span> <span class="hljs-string">`precision mediump float; `</span> +</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>Every pixel needs to create at least one ray
<code>Ray</code>s are just <code>point</code>s x/y/z with a direction (<code>vector</code>), also x/y/z
<code>ior</code> is the “Index of Refraction” in the volume the ray was cast</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-string">`    
    struct Ray {
        vec3 point;
        vec3 vector;
        float ior;
    };
`</span> +</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p><code>Material</code>s are a bit of a mess, their “shape” is shared between
JavaScript and GLSL, full descriptions of shape can be found in
<a href="scene.html#materials">the js scene docs</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-string">`    
    struct Material {
        vec3 colourOrAlbedo;
        float ambient;
        float diffuseOrRoughness;
        float specularOrMetallic;
        float refraction;
        int isTranslucent;
    };
`</span> +</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p><code>Hit</code>s describe the intersection of a <code>Ray</code> and an object</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-string">`    
    struct Hit {
        float distance;
        Material material;
        vec3 normal;
        vec3 position;
        Ray ray;
    };
`</span> +</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p><code>Sphere</code>s in our case are mathematical spheres
They are a simple point, a radius, and a pointer to an element in the <code>materials</code>
array</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-string">`    
    struct Sphere {
        vec3 point;
        float radius;
        int material;
    };
`</span> +</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p><code>SphereDistance</code> lets us return a <code>Sphere</code> and how far we are from it</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-string">`    
    struct SphereDistance {
        float distance;
        Sphere sphere;
    };
`</span> +</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p><code>Triangle</code>s share a “shape” with JavaScript and are <a href="scene.html#triangles">documented here</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-string">`   
    struct Triangle {
        vec3 a;
        vec3 b;
        vec3 c;
        vec3 normal;
        int material;
    };
`</span> +</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p><code>TriangleDistance</code> lets us return a <code>Triangle</code>, how far we are from it, the
point at which our ray intersected the triangle, and “barycentric” coordinates
<code>u</code> and <code>v</code> for future texturing</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-string">`    
    struct TriangleDistance {
        float distance;
        Triangle triangle;
        vec3 intersectPoint;
        float u;
        float v;
    };
`</span> +</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p><code>PointLight</code> is a wrapper around a <code>point</code>, lights will have colours in the future</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-string">`
    struct PointLight {
        vec3 point;
    };
`</span> +</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>we have a few constants, <code>bg</code>, the background colour is configurable</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-string">`
    const vec3 bgColour = vec3(<span class="hljs-subst">${bg.r}</span>, <span class="hljs-subst">${bg.g}</span>, <span class="hljs-subst">${bg.b}</span>);
    const float PI = <span class="hljs-subst">${<span class="hljs-built_in">Math</span>.PI}</span>;
    const float refractionMedium = 1.0;
`</span> +</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>uniforms are values uploaded by javascript, there are a few essentialls here</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-string">`
    uniform float aspectRatio;
    uniform vec3 cameraPos;
    uniform mat4 cameraMatrix;
    uniform float globalAmbientIntensity;
    uniform float height;
    uniform float scale;
    uniform float width;
`</span> +</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>For now we’ll also use some uniforms to select rending options
in a performant app we’d want to dnyamically generate faster shaders
that can skip this check and have the models baked in</p>
<p>for now let’s set them up here</p>
<p>0 for Blinn Phong, 1 for PBR</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-string">`
    uniform int shadingModel;
`</span> +</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>anti-aliasing amount 0 - none, 2 - some, 4, reasonable but 4x the work</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-string">`
    uniform int aa;
`</span> +</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>we have a few “look up” tables here
GLSL arrays in this version aren’t so much random access chunks of memory
as they are “fixed access” chunks of memory.  GLSL wants to know up front
exactly how much space to use.</p>
<p><em>Additionally</em> outside of loops we are <em>not allowed</em> to reference arrays 
with variables.  This is a seemingly severe limitation but we can hack
around it</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-string">`
    uniform Material materials[<span class="hljs-subst">${materialCount}</span>];
    uniform Sphere spheres[<span class="hljs-subst">${sphereCount}</span>];
    uniform PointLight pointLights[<span class="hljs-subst">${lightCount}</span>];
    uniform Triangle triangles[<span class="hljs-subst">${triangleCount}</span>];
`</span> +</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>in GLSL if you want to call your functions “out of the order their written” you’ll
need to declare them upfront</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-string">`
    float sphereIntersection(Sphere sphere, Ray ray);
    TriangleDistance triangleIntersection(Triangle triangle, Ray ray);
    SphereDistance intersectSpheres(Ray ray, bool useAnyHit);
    TriangleDistance intersectTriangles(Ray ray, bool useAnyHit);
    vec3 cast1(Ray ray);
    vec3 cast2(Ray ray);
    vec3 cast3(Ray ray);
    vec3 sphereNormal(Sphere sphere, vec3 pos);
    vec3 surfacePhong(Hit hit);
    vec3 surfacePbr1(Hit hit);
    vec3 surfacePbr2(Hit hit);
    bool isLightVisible(vec3 pt, vec3 light, vec3 normal);
    bool areEqualish(float a, float b);
    vec3 primaryRay(float xo, float yo);
    float DistributionGGX(vec3 N, vec3 H, float roughness);
    float GeometrySchlickGGX(float NdotV, float roughness);
    float GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness);
    vec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness);
    Material getMaterial(int index);
`</span> +</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p><a name="fragmentMain"></a></p>
<h4 id="fragment-main">Fragment Main</h4>
<p>Like the vector shader, the fragment shader also has to have a main function
in the fragment shader, our requirement is to set <code>gl_FragColor</code>.  <code>gl_FragColor</code> is
a <code>vec4</code> r/g/b/a</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-string">`    void main() {
`</span> +</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>we’ll support casting 2, 4, or 1 rays from the camera to <em>this</em> pixel
the more rays the better the anti-aliasing.  That said these values literally
multiply the cost of the function per pixel, so 4xAA 1080P mean <code>1920 * 1080 * 4</code>
primary rays!</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-string">`
        vec3 total = vec3(0.0);
`</span> +</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>we need to average the colours at the end of this, and we’ll use this divisor to do it</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-string">`
        float divisor = 1.0;

        if (aa == 2) {
            divisor = 2.0;
            total += primaryRay(0.25, 0.25).rgb;
            total += primaryRay(0.75, 0.75).rgb;
        } else if (aa == 4) {
            divisor = 4.0;
            total += primaryRay(0.25, 0.25).rgb;
            total += primaryRay(0.75, 0.25).rgb;
            total += primaryRay(0.75, 0.75).rgb;
            total += primaryRay(0.25, 0.75).rgb;
        } else {
            total += primaryRay(0.5, 0.5).rgb;
        }

`</span> +</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>finally we set <code>gl_FragColor</code>, averaging the rays we cast
we hard code the alpha value to <code>1.0</code> as we’ll be doing
translucency differently</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-string">`
        gl_FragColor = vec4(total.rgb / divisor, 1.0);
    }
`</span> +</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p><a name="primaryRay"></a></p>
<h4 id="primaryray">primaryRay</h4>
<p>the primaryRay function computes the primary ray from the pinhole camera location
to the <em>portion of the pixel</em> specified by <code>xo</code> and <code>yo</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-string">`
    vec3 primaryRay(float xo, float yo) {
        float px = gl_FragCoord.x;
        float py = gl_FragCoord.y;

        float x = (2.0 * (px + xo) / width - 1.0) * scale;
        float y = (2.0 * (py + yo) / height - 1.0) * scale * 1.0 / aspectRatio;

        vec3 dir = vec3(0.0, 0.0, 0.0);

        dir.x = x    * cameraMatrix[0][0] + y * cameraMatrix[1][0] + -1.0 * cameraMatrix[2][0];
        dir.y = y    * cameraMatrix[0][1] + y * cameraMatrix[1][1] + -1.0 * cameraMatrix[2][1];
        dir.z = -1.0 * cameraMatrix[0][2] + y * cameraMatrix[1][2] + -1.0 * cameraMatrix[2][2];

        Ray ray = Ray(cameraPos, normalize(dir), refractionMedium);

        return cast1(ray);
    }
`</span> +</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p><a name="trace"></a></p>
<h4 id="trace">trace</h4>
<p>the trace function checks if a ray intersects <em>any</em> spheres <em>or</em> triangles
in the scene.  In the future it’s ripe for “acceleration”</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-string">`
    Hit trace(Ray ray) {
       SphereDistance sd = intersectSpheres(ray, false);
       TriangleDistance td = intersectTriangles(ray, false);
       if (sd.distance &lt;= 0.0 &amp;&amp; td.distance &lt;= 0.0) {
           return Hit(
               -1.0,
               Material(vec3(0.0, 0.0, 0.0), 0.0, 0.0, 0.0, 0.0, 0),
               vec3(0.0, 0.0, 0.0),
               vec3(0.0, 0.0, 0.0),
               ray
           );
       }

       if (sd.distance &gt;= 0.0 &amp;&amp; td.distance &gt;= 0.0) {
           if (sd.distance &lt; td.distance) {
            vec3 pointAtTime = ray.point + vec3(ray.vector.xyz * sd.distance);
            vec3 normal = sphereNormal(sd.sphere, pointAtTime);

            return Hit(
                sd.distance,
                getMaterial(sd.sphere.material),
                normal,
                sd.sphere.point,
                ray
            );
           } else {
            return Hit(
                td.distance,
                getMaterial(td.triangle.material),
                td.triangle.normal,
                td.intersectPoint,
                ray
            );
           }
       }


       if (sd.distance &gt;= 0.0) {
        vec3 pointAtTime = ray.point + vec3(ray.vector.xyz * sd.distance);
        vec3 normal = sphereNormal(sd.sphere, pointAtTime);

        return Hit(
            sd.distance,
            getMaterial(sd.sphere.material),
            normal,
            sd.sphere.point,
            ray
        );
       }

       return Hit(
            td.distance,
            getMaterial(td.triangle.material),
            td.triangle.normal,
            td.intersectPoint,
            ray
        );
    }
`</span> +</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>the <code>castX</code> functions cast rays and call a surface function to
get the colour</p>
<p>right now they’re a mess in that they are being hard code toggled
to produce results</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-string">`
    vec3 cast1(Ray ray) {
        Hit hit = trace(ray);

        if (hit.distance &lt; 0.0) {
            return bgColour;
        }

        if (shadingModel == 0) {
            return surfacePbr1(hit);
        } else {
            return surfacePhong(hit);
        }
    }

    vec3 cast2(Ray ray) {
        Hit hit = trace(ray);

        if (hit.distance &lt; 0.0) {
            return bgColour;
        }

        if (shadingModel == 0) {
            return surfacePbr2(hit);
        } else {
            return surfacePhong(hit);
        }
    }

    vec3 cast3(Ray ray) {
        Hit hit = trace(ray);

        if (hit.distance &lt; 0.0) {
            return bgColour;
        }

        return surfacePhong(hit);
    }
`</span> +</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>compute the normal of a sphere</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-string">`
    vec3 sphereNormal(Sphere sphere, vec3 pos) {
        return normalize(pos - sphere.point);
    }
`</span> +</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>ray spehre intersection iterator</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-string">`

    SphereDistance intersectSpheres(Ray ray, bool useAnyHit) {
        SphereDistance sd = SphereDistance(-1.0, Sphere(
            vec3(0.0, 0.0, 0.0), 
            -1.0,
            0));
        for (int i = 0; i &lt; <span class="hljs-subst">${sphereCount}</span>; i += 1) {
            Sphere s = spheres[i];
            float dist = sphereIntersection(s, ray);
            if (dist &gt;= 0.0) {
</span></pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>we’re temporarily hacking in an object that casts no shadow </p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                Material m = getMaterial(sd.sphere.material);
                <span class="hljs-keyword">if</span> (sd.distance &lt;= <span class="hljs-number">0.0</span> || dist &lt; sd.distance) {
                    <span class="hljs-keyword">if</span> (useAnyHit == <span class="hljs-literal">false</span> || m.isTranslucent == <span class="hljs-number">0</span>) {
                        sd.distance = dist;
                        sd.sphere = s;
                    }
                }
                <span class="hljs-keyword">if</span> (useAnyHit) {</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>we’re temporarily hacking in an object that casts no shadow </p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                    <span class="hljs-keyword">if</span> (m.isTranslucent != <span class="hljs-number">0</span>) {
                        sd.distance = dist;
                        sd.sphere = s;
                        <span class="hljs-keyword">return</span> sd;
                    }
                }
            }
        }
        <span class="hljs-keyword">return</span> sd;
    }
<span class="hljs-string">` +
</span></pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>Ray triangle intersection iterator</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-string">`
    TriangleDistance intersectTriangles(Ray ray, bool useAnyHit) {
        TriangleDistance least = TriangleDistance(
            -1.0, 
            Triangle(
                vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), 
                vec3(0.0, 0.0, 0.0), 
                0),
            vec3(0.0, 0.0, 0.0),
            0.0,
            0.0);

        for (int i = 0; i &lt; <span class="hljs-subst">${triangleCount}</span>; i += 1) {
            Triangle t = triangles[i];
            TriangleDistance td = triangleIntersection(t, ray);
            if (td.distance &gt;= 0.0) {
</span></pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>we’re temporarily hacking in an object that casts no shadow </p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                Material m = getMaterial(td.triangle.material);
                <span class="hljs-keyword">if</span> (least.distance &lt;= <span class="hljs-number">0.0</span> || td.distance &lt; least.distance) {
                    <span class="hljs-keyword">if</span> (useAnyHit == <span class="hljs-literal">false</span> || m.isTranslucent == <span class="hljs-number">0</span>) {
                        least = td;
                    }
                }
                <span class="hljs-keyword">if</span> (useAnyHit == <span class="hljs-literal">true</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p>we’re temporarily hacking in an object that casts no shadow </p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                    <span class="hljs-keyword">if</span> (m.isTranslucent != <span class="hljs-number">0</span>) {
                        <span class="hljs-keyword">return</span> td;
                    }
                }
            }
        }
        <span class="hljs-keyword">return</span> least;
    }
<span class="hljs-string">` +
</span></pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>calculate the intersection of a ray and a triangle</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-string">`
    TriangleDistance triangleIntersection(Triangle triangle, Ray ray) {
        TriangleDistance td = TriangleDistance(
            -1.0, 
            triangle,
            vec3(0.0, 0.0, 0.0),
            0.0,
            0.0);
    
</span></pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p>compute full scale normal</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        vec3 v0v1 = triangle.b - triangle.a;
        vec3 v0v2 = triangle.c - triangle.a;
        vec3 pvec = cross(ray.vector, v0v2);
        float det = dot(v0v1, pvec);

        <span class="hljs-keyword">if</span> (abs(det) &lt; ${epsilon}) {
            <span class="hljs-keyword">return</span> td;
        }

        float invDet = <span class="hljs-number">1.0</span> / det;

        vec3 tvec = ray.point - triangle.a;
        float u = dot(tvec, pvec) * invDet;
        <span class="hljs-keyword">if</span> (u &lt; <span class="hljs-number">0.0</span> || u &gt; <span class="hljs-number">1.0</span>) {
            <span class="hljs-keyword">return</span> td;
        }

        vec3 qvec = cross(tvec, v0v1);
        float v = dot(ray.vector, qvec) * invDet;
        <span class="hljs-keyword">if</span> (v &lt; <span class="hljs-number">0.0</span> || (u + v) &gt; <span class="hljs-number">1.0</span>) {
            <span class="hljs-keyword">return</span> td;
        }

        td.u = u;
        td.v = v;
        td.distance = dot(v0v2, qvec) * invDet;
        td.intersectPoint = vec3(triangle.a.xyz + u * v0v1.xyz + v * v0v2.xyz);

        <span class="hljs-keyword">return</span> td;
    }

    float sphereIntersection(Sphere sphere, Ray ray) {
        vec3 eyeToCentre = sphere.point - ray.point;
        float v = dot(eyeToCentre, ray.vector);
        float eoDot = dot(eyeToCentre, eyeToCentre);
        float discriminant = (sphere.radius * sphere.radius) - eoDot + (v * v);

        <span class="hljs-keyword">if</span> (discriminant &lt; <span class="hljs-number">0.0</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-number">-1.0</span>;
        }

        <span class="hljs-keyword">return</span> v - sqrt(discriminant);
    }
<span class="hljs-string">` +
</span></pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p>is there a light visible from a point? (shadows)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-string">`
    bool isLightVisible(vec3 pt, vec3 light, vec3 normal) {
        vec3 unit = normalize(light - pt);
        Ray ray = Ray(pt + vec3(normal.xyz + <span class="hljs-subst">${epsilon}</span>), unit, refractionMedium);
        SphereDistance sd = intersectSpheres(ray, true);

        if (sd.distance &gt; 0.0) {
            return false;
        }

        TriangleDistance td = intersectTriangles(ray, true);

        return td.distance &lt; 0.0;
    }
`</span> +</pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p>colour space conversion functions</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-string">`
    float sRgb8ChannelToLinear(float colour8) {
        const float sThresh = 0.04045;

        float colourf = colour8 / 255.0;
        if (colourf &lt;= sThresh) {
            return colourf / 12.92;
        }

        return pow((colourf + 0.055) / 1.055, 2.4);
    }

    vec3 sRgb8ToLinear(vec3 srgb8) {
        return vec3(
            sRgb8ChannelToLinear(srgb8.r),
            sRgb8ChannelToLinear(srgb8.g),
            sRgb8ChannelToLinear(srgb8.b)
            );
    }

    float linearChannelToSrgbF(float linear) {
        if (linear &lt;= 0.0031308) {
            return (linear * 12.92);
        }

        return (1.055 * pow(linear, 1.0/2.4) - 0.055);
    }

    vec3 linearToSrgbF(vec3 linear) {
        return vec3(
            linearChannelToSrgbF(linear.r),
            linearChannelToSrgbF(linear.g),
            linearChannelToSrgbF(linear.b)
        );
    }

`</span> +</pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <p>the bulk of the PBR loop</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-string">`
    vec3 surfacePbrReflectance(Hit hit, vec3 N, vec3 V, vec3 R, vec3 reflectColour, vec3 refractColour) {
        Material material = hit.material;
        vec3 albedo = sRgb8ToLinear(material.colourOrAlbedo); // pow(material.colourOrAlbedo.rgb, vec3(2.2));
        float ao = material.ambient;
        float metallic = material.specularOrMetallic;
        float roughness = material.diffuseOrRoughness;

        vec3 F0 = vec3(<span class="hljs-subst">${defaultF0}</span>); 
        F0 = mix(F0, albedo, metallic);

</span></pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p>reflectance equation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        bool didLight = <span class="hljs-literal">false</span>;
        vec3 Lo = vec3(<span class="hljs-number">0.0</span>);
        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; ${lightCount}; i += <span class="hljs-number">1</span>) {
            <span class="hljs-keyword">if</span> (isLightVisible(hit.position, pointLights[i].point, hit.normal) == <span class="hljs-literal">true</span>) {
                didLight = <span class="hljs-literal">true</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <p>calculate per-light radiance</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                vec3 lightDir = pointLights[i].point - hit.position;
                float distance = length(lightDir);
                vec3 L = normalize(lightDir);
                vec3 H = normalize(V + L);
                float attenuation = <span class="hljs-number">1.0</span> / (distance * distance);</pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <p>@todo light colour</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                vec3 lightColour = sRgb8ToLinear(vec3(<span class="hljs-number">255.0</span>, <span class="hljs-number">255.0</span>, <span class="hljs-number">255.0</span>) * <span class="hljs-number">35.0</span>);
                vec3 radiance = lightColour.rgb * attenuation;</pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <p>Cook-Torrance BRDF</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                float NDF = DistributionGGX(N, H, roughness);   
                float G   = GeometrySmith(N, V, L, roughness);      
                vec3 F    = fresnelSchlickRoughness(max(dot(H, V), <span class="hljs-number">0.0</span>), F0, roughness);

                vec3 nominator    = NDF * G * F; 
                float denominator = <span class="hljs-number">4.0</span> * max(dot(N, V), <span class="hljs-number">0.0</span>) * max(dot(N, L), <span class="hljs-number">0.0</span>) + <span class="hljs-number">0.001</span>; <span class="hljs-comment">// 0.001 to prevent divide by zero.</span>
                <span class="hljs-comment">/** @todo use real physics, this violates the PBR to some extent */</span>
                vec3 specular = nominator / denominator + F * reflectColour * metallic;</pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <p>kS is equal to Fresnel</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                vec3 kS = F;</pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <p>for energy conservation, the diffuse and specular light can’t
be above 1.0 (unless the surface emits light); to preserve this
relationship the diffuse component (kD) should equal 1.0 - kS.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                vec3 kD = vec3(<span class="hljs-number">1.0</span>) - kS;</pre></div></div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <p>multiply kD by the inverse metalness such that only non-metals 
have diffuse lighting, or a linear blend if partly metal (pure metals
have no diffuse light).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                kD *= <span class="hljs-number">1.0</span> - metallic;</pre></div></div>
            
        </li>
        
        
        <li id="section-47">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <p>scale light by NdotL</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                float NdotL = max(dot(N, L), <span class="hljs-number">0.0</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-48">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>
              <p>add to outgoing radiance Lo</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                Lo += (kD * (albedo + refractColour) / PI + specular) * radiance * NdotL;  <span class="hljs-comment">// note that we already multiplied the BRDF by the Fresnel (kS) so we won't multiply by kS again</span>
            }
        }

        <span class="hljs-keyword">if</span> (didLight == <span class="hljs-literal">false</span>) {
            <span class="hljs-keyword">return</span> vec3(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>);
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-49">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-49">&#182;</a>
              </div>
              <p>ambient lighting (will replace this ambient lighting with 
environment lighting).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        vec3 ambient = vec3(<span class="hljs-number">0.03</span>) * albedo * ao;
    
        vec3 colour = ambient + Lo;</pre></div></div>
            
        </li>
        
        
        <li id="section-50">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-50">&#182;</a>
              </div>
              <p>HDR tonemapping</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        colour = colour / (colour + vec3(<span class="hljs-number">1.0</span>));

        colour = linearToSrgbF(colour);

        <span class="hljs-keyword">return</span> colour;
    }
<span class="hljs-string">` +
</span></pre></div></div>
            
        </li>
        
        
        <li id="section-51">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-51">&#182;</a>
              </div>
              <p>PBR Surface functions</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-string">`
    vec3 surfacePbr1(Hit hit) {
        vec3 N = hit.normal;
        vec3 V = normalize(hit.ray.point - hit.position);
        vec3 R = reflect(-V, N);  
        vec3 reflectColour = cast2(Ray(hit.position, R, hit.ray.ior)).rgb;
        vec3 refractColour = vec3(0.0, 0.0, 0.0);

        if (hit.material.isTranslucent == 1) {
            if (areEqualish(hit.ray.ior, hit.material.refraction) == false) {
            }
        }

        return surfacePbrReflectance(hit, N, V, R, reflectColour, refractColour);
    }

    vec3 surfacePbr2(Hit hit) {
        vec3 N = hit.normal;
        vec3 V = normalize(hit.ray.point - hit.position);
        vec3 R = reflect(-V, N);   

        return surfacePbrReflectance(hit, N, V, R, vec3(1.0, 1.0, 1.0), vec3(0.0, 0.0, 0.0));
    }
`</span> +</pre></div></div>
            
        </li>
        
        
        <li id="section-52">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-52">&#182;</a>
              </div>
              <p>Blinn Phong functions</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-string">`
    vec3 surfacePhong(Hit hit) {
        Material material = hit.material;
        vec3 fullColour = vec3(material.colourOrAlbedo.rgb / 255.0);
        vec3 diffuse = vec3(0.0, 0.0, 0.0);
        vec3 specular = vec3(0.0, 0.0, 0.0);

        for (int i = 0; i &lt; <span class="hljs-subst">${lightCount}</span>; i += 1) {
            if (isLightVisible(hit.position, pointLights[i].point, hit.normal) == true) {
</span></pre></div></div>
            
        </li>
        
        
        <li id="section-53">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-53">&#182;</a>
              </div>
              <p>@todo light colour</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                vec3 lightColour = vec3(<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>);
                vec3 lightDir = normalize(pointLights[i].point - hit.position);
                float lightIntensity = <span class="hljs-number">1.0</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-54">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-54">&#182;</a>
              </div>
              <p>diffuse</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                float dco = dot(hit.normal, lightDir);
                <span class="hljs-keyword">if</span> (dco &lt; <span class="hljs-number">0.0</span>) { dco = <span class="hljs-number">0.0</span>; }

                diffuse += vec3(fullColour.rgb * lightIntensity * dco);</pre></div></div>
            
        </li>
        
        
        <li id="section-55">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-55">&#182;</a>
              </div>
              <p>specular</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                vec3 halfway = normalize(lightDir - hit.ray.vector);
                float sco = dot(hit.normal, normalize(halfway));
                <span class="hljs-keyword">if</span> (sco &lt; <span class="hljs-number">0.0</span>) { sco = <span class="hljs-number">0.0</span>; }
                
                specular += vec3(lightColour.rgb * lightIntensity * pow(sco, ${phongSpecularExp}));
            }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-56">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-56">&#182;</a>
              </div>
              <p>calculate ambient light</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        vec3 ambient = vec3(fullColour.rgb * globalAmbientIntensity);
        ambient = vec3(ambient.rgb + (fullColour.rgb * material.ambient));

        <span class="hljs-keyword">return</span> ambient.rgb + diffuse.rgb * material.diffuseOrRoughness + specular.rgb * material.specularOrMetallic;
    }
<span class="hljs-string">` +
</span></pre></div></div>
            
        </li>
        
        
        <li id="section-57">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-57">&#182;</a>
              </div>
              <p>are two floating points roughly equal?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-string">`
    bool areEqualish(float a, float b) {
        if (abs(a - b) &lt; <span class="hljs-subst">${epsilon}</span>) {
            return true;
        }
        return false;
    }
`</span> +</pre></div></div>
            
        </li>
        
        
        <li id="section-58">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-58">&#182;</a>
              </div>
              <p>hack around GLSL’s inability to index arrays</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-string">`
    Material getMaterial(int index) {
        if (index == 0) {
            return materials[0];
        }

        if (index == 1) {
            return materials[1];
        }

        if (index == 2) {
            return materials[2];
        }

        if (index == 3) {
            return materials[3];
        }

        if (index == 4) {
            return materials[4];
        }

        if (index == 5) {
            return materials[5];
        }

        if (index == 6) {
            return materials[6];
        }

        return materials[0];
    }
`</span> +</pre></div></div>
            
        </li>
        
        
        <li id="section-59">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-59">&#182;</a>
              </div>
              <p>PBR Computations
essentially straight from <a href="https://learnopengl.com/PBR/Theory" title="Learn OpenGL`">Learn OpenGL</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-string">`
</span></pre></div></div>
            
        </li>
        
        
        <li id="section-60">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-60">&#182;</a>
              </div>
              <hr>

            </div>
            
        </li>
        
        
        <li id="section-61">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-61">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>    float DistributionGGX(vec3 N, vec3 H, float roughness) {
        float a = roughness*roughness;
        float a2 = a*a;
        float NdotH = max(dot(N, H), <span class="hljs-number">0.0</span>);
        float NdotH2 = NdotH*NdotH;

        float nom   = a2;
        float denom = (NdotH2 * (a2 - <span class="hljs-number">1.0</span>) + <span class="hljs-number">1.0</span>);
        denom = PI * denom * denom;

        <span class="hljs-keyword">return</span> nom / denom;
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-62">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-62">&#182;</a>
              </div>
              <hr>

            </div>
            
        </li>
        
        
        <li id="section-63">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-63">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>    float GeometrySchlickGGX(float NdotV, float roughness) {
        float r = (roughness + <span class="hljs-number">1.0</span>);
        float k = (r*r) / <span class="hljs-number">8.0</span>;

        float nom   = NdotV;
        float denom = NdotV * (<span class="hljs-number">1.0</span> - k) + k;

        <span class="hljs-keyword">return</span> nom / denom;
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-64">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-64">&#182;</a>
              </div>
              <hr>

            </div>
            
        </li>
        
        
        <li id="section-65">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-65">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>    float GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {
        float NdotV = max(dot(N, V), <span class="hljs-number">0.0</span>);
        float NdotL = max(dot(N, L), <span class="hljs-number">0.0</span>);
        float ggx2 = GeometrySchlickGGX(NdotV, roughness);
        float ggx1 = GeometrySchlickGGX(NdotL, roughness);

        <span class="hljs-keyword">return</span> ggx1 * ggx2;
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-66">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-66">&#182;</a>
              </div>
              <hr>

            </div>
            
        </li>
        
        
        <li id="section-67">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-67">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>    vec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {
        <span class="hljs-keyword">return</span> F0 + (max(vec3(<span class="hljs-number">1.0</span> - roughness), F0) - F0) * pow(<span class="hljs-number">1.0</span> - cosTheta, <span class="hljs-number">5.0</span>);
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-68">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-68">&#182;</a>
              </div>
              <hr>

            </div>
            
        </li>
        
        
        <li id="section-69">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-69">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-string">`;
}

</span></pre></div></div>
            
        </li>
        
    </ul>
  </div>
  <script type="text/javascript" src="https://literate-raytracer.michaeljbennett.info/index.js"></script>
</body>
</html>
